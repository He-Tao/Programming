<h1 id="problem-14.-longest-collatz-sequence">Problem 14. Longest Collatz sequence</h1>
<h2 id="题目">题目</h2>
<p>The following iterative sequence is defined for the set of positive integers:</p>
<p><span class="math">\[n → n/2 (n is even)\]</span> <span class="math">\[n → 3n + 1 (n is odd)\]</span> Using the rule above and starting with 13, we generate the following sequence: <span class="math">\[13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1\]</span></p>
<p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</p>
<p>Which starting number, under one million, produces the longest chain?</p>
<p><em>NOTE</em>: Once the chain starts the terms are allowed to go above one million.</p>
<p><a href="https://projecteuler.net/problem=14%20title=&quot;Problem%2014&quot;">Problem 14. Longest Collatz sequence</a></p>
<h2 id="翻译">翻译</h2>
<p>以下迭代序列定义在整数集合上： <span class="math">\[n → n/2 (当n是偶数时)\]</span> <span class="math">\[n → 3n + 1 (当n是奇数时)\]</span> 应用以上规则，并且以数字13开始，我们得到以下序列： <span class="math">\[ 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \]</span> 可以看出这个以13开始以1结束的序列包含10个项。虽然还没有被证明（Collatz问题），但是人们认为在这个规则下，以任何数字开始都会以1结束。</p>
<p>以哪个不超过100万的数字开始，能给得到最长的序列？</p>
<p><em>注意</em>: 一旦序列开始之后，也就是从第二项开始，项是可以超过100万的。</p>
<p><a href="http://pe.spiritzhang.com/index.php/2011-05-11-09-44-54/15-14100%20title=&quot;题目14&quot;">题目14:找出以100万以下的数字开始的最长序列</a></p>
<h2 id="题解python">题解(Python)</h2>
<p>答案(answer): 837799</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python</span>
<span class="co"># -*- coding: utf-8</span>

num = [<span class="dv">0</span> <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">1000001</span>)]

<span class="kw">def</span> collatz(n):
    <span class="kw">if</span> n == <span class="dv">1</span>:
        <span class="kw">return</span> <span class="dv">1</span>
    ans = <span class="dv">0</span>
    <span class="kw">if</span> n &gt; <span class="dv">1000000</span>:
        <span class="kw">if</span> n % <span class="dv">2</span> == <span class="dv">0</span>:
            ans = collatz(n // <span class="dv">2</span>) + <span class="dv">1</span>
        <span class="kw">else</span>:
            ans = collatz(<span class="dv">3</span> * n + <span class="dv">1</span>) + <span class="dv">1</span>
    <span class="kw">else</span>:
        <span class="kw">if</span> num[n] == <span class="dv">0</span>:
            <span class="kw">if</span> n % <span class="dv">2</span> == <span class="dv">0</span>:
                num[n] = collatz(n // <span class="dv">2</span>) + <span class="dv">1</span>
            <span class="kw">else</span>:
                num[n] = collatz(<span class="dv">3</span> * n + <span class="dv">1</span>) + <span class="dv">1</span>
        ans = num[n]
    <span class="kw">return</span> ans

max_index = <span class="dv">0</span>

<span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, <span class="dv">1000001</span>):
    <span class="kw">if</span> num[i] == <span class="dv">0</span>:
        num[i] = collatz(i)
        <span class="kw">if</span> num[i] &gt; num[max_index]:
            max_index = i

<span class="dt">print</span>(max_index)

<span class="co"># vim: set sw=4, ts=4, fileencoding=utf-8</span></code></pre>
