# include <stdio.h>
/*
题目描述 Description
检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。
列号
　 1　 2　 3　 4　 5　 6
　-------------------------
1 |　 | O |　 |　 |　 |　 |
　-------------------------
2 |　 |　 |　 | O |　 |　 |
　-------------------------
3 |　 |　 |　 |　 |　 | O |
　-------------------------
4 | O |　 |　 |　 |　 |　 |
　-------------------------
5 |　 |　 | O |　 |　 |　 |
　-------------------------
6 |　 |　 |　 |　 | O |　 |
　-------------------------
上面的布局可以用序列2 4 6 1 3 5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下： 
行号 1 2 3 4 5 6 
列号 2 4 6 1 3 5 
这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。
最后一行是解的总个数。
*/
int buf[15], flag[15], sum[15], mark1, mark2, mark;
int n, t;
void queen(int m)
{
	int i, j;
	if(m > n)
	{
		t++;
		if(t <= 3)
		{
			for(i = 1; i <= n; i++)
				printf("%d ", buf[i]);
			printf("\n");
		}		
	}
	else
	{
		for(i = 1; i <= n; i++)
		{
			buf[m] = i;
			if(flag[i] == 0)
			{
				mark1 = buf[m] - m, mark2 = buf[m] + m;
				for(j = 1; j < m; j++)
				{
					if(m != 1)
					{
						if(buf[j] - j == mark1 || buf[j] + j == mark2)
							break;
					}
				}
				if(j >= m)
				{
					flag[i] = 1;
					queen(m+1);
					flag[i] = 0;
				}
			}
		}
	}
}

int main()
{
	scanf("%d", &n);
	queen(1);
	printf("%d\n", t);

	return 0;
}

/*
输入描述 Input Description
一个数字N表示棋盘是N x N大小的。
输出描述 Output Description
前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。
 
样例输入 Sample Input
6
样例输出 Sample Output
2 4 6 1 3 5 
3 6 2 5 1 4 
4 1 5 2 6 3 
4
数据范围及提示 Data Size & Hint
6 <= N <= 13
*/
