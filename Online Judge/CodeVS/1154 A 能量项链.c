# include <stdio.h>
# include <string.h>
/*
题目描述 Description
在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着
某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸
收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾
标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。
需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能
量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。
例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗
珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：
(4⊕1)=10*2*3=60。
这一串项链可以得到最优值的一个聚合顺序所释放的总能量为
((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。
*/
int main()
{
	int bead[201], n, dp[201][201], i, j, k, len, max, tmp;
	scanf("%d", &n);
	for(i = 0; i < n; ++i)             //从 0 开始，方便后面的取模运算
		scanf("%d", bead+i);
	for(len = 2; len <= n; ++len)
	{
		for(i = 0; i < n; ++i)
		{
			j = i + len - 1, max = 0;
			for(k = i; k < j; ++k)
			{
				tmp = dp[i][k % n] + dp[(k+1) % n][j % n] + bead[i] * bead[(k+1) % n] * bead[(j+1) % n];
				max = max > tmp ? max : tmp;
			}
			dp[i][j % n] = max;
		}
	}
	max = dp[0][n-1];
	for(i = 1; i < n; ++i)
		max = max > dp[i][i-1] ? max : dp[i][i-1];
	printf("%d", max);
	
	return 0;
}

/*
输入描述 Input Description
第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗
珠子的头标记（1≤i≤N），当i<N< span>时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。
至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
输出描述 Output Description
只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。
样例输入 Sample Input
4
2 3 5 10
样例输出 Sample Output
710
数据范围及提示 Data Size & Hint
无
*/
