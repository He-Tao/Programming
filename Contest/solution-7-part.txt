

B. Huffman编码
一个性质：不论一步如何选择，所有集合的频数组成的多重集是唯一的。
一个简单的想法是把每一步的选择数量求出来，然后乘起来。但是这样是不行的，因为某些合并是可交换的。 例子： 1 1 1 1 先合并前两个，得到2 1 1 再合并后两个，得到2 2
先合并后两个，得到1 1 2 再合并前两个，得到2 2
这两种方法得到的结果是一样的，但是路线不一样。
解决方法：将可交换的合并同时考虑。我们发现仍然可以求出来可能的方案数。 例子： 1 1 1 1 无论如何会合并成 2 2 此时合并方案数为3*2^2=12。
我们发现只有出现多个相同的数的时候才会有可交换的合并。所以容易计算。

C. 树上的好路径
换句话说，我们需要求出这样的路径数： “恰包含一个权值比c小的点，且其他点之权值大等于c，且存在至少一个点的权值为c。” 注意到它等于 “恰包含一个权值比c小的店，且其他点之权值大等于c”的路径数，减去“恰包含一个权值比c小的店，且其他点之权值大等于c+1”的路径数。这两者都是易于计算的。
